// that background IS generated by AI.
'use client';
import { useMotionValueEvent, useScroll, useSpring } from 'motion/react';
import React, { useEffect, useMemo, useRef } from 'react';
import * as THREE from 'three';

interface AestheticFluidBgProps {
	colors?: string[];
	dom?: string;
	seed?: number;
	loop?: boolean;
	resize_mode?: string;
	radius_inner?: number;
	radius_outer?: number;
	quality?: 'low' | 'medium' | 'high'; // Added quality prop
}

interface MorphData {
	anchorX: number;
	anchorY: number;
	anchorZ: number;
	anchorRadius: number;
	moveToX: number;
	moveToY: number;
	moveToZ: number;
}

interface MorphDataMap {
	[key: string]: MorphData;
}

// Move outside component to prevent recreation
const defaultColors = ['#F00911', '#F3AA00', '#F6EE0B', '#39E90D', '#195ED2', '#F00911'];
const morphdata: MorphDataMap = {
	'1': {
		anchorX: 240,
		anchorY: -200,
		anchorZ: 0,
		anchorRadius: 900,
		moveToX: 260,
		moveToY: 160,
		moveToZ: 400
	},
	'2': {
		anchorX: -240,
		anchorY: 200,
		anchorZ: 0,
		anchorRadius: 900,
		moveToX: -260,
		moveToY: -160,
		moveToZ: 400
	}
};

// Shader code as constants to prevent string recreation in render cycles
const VERTEX_SHADER = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const RTT_FRAGMENT_SHADER = `
  #ifdef GL_ES
  precision mediump float;
  #endif

  #define TWO_PI 6.28318530718

  uniform vec2 u_resolution;
  uniform float u_time;

  uniform vec3 u_color_0;
  uniform vec3 u_color_1;
  uniform vec3 u_color_2;
  uniform vec3 u_color_3;
  uniform vec3 u_color_4;
  uniform vec3 u_color_5;
  uniform vec4 u_dye_0;
  uniform vec4 u_dye_1;
  uniform vec4 u_dye_2;
  uniform vec4 u_dye_3;
  uniform vec4 u_dye_4;
  uniform vec4 u_dye_5;

  varying vec2 vUv;

  vec4 blurDot(vec3 color, vec2 st, vec2 pos, float inner, float outer) {
    float pct = distance(st, pos);   
    vec2 dist = st - pos;
    float alpha = 1.0 - smoothstep(inner, outer, pct);
        
    return vec4(color.rgb, alpha);
  }

  void main() {
    vec2 st = vUv;
    vec3 color = vec3(1.0);        

    vec4 dot_0 = blurDot(u_color_0, st, u_dye_0.xy, u_dye_0[2], u_dye_0[3]);
    vec4 dot_1 = blurDot(u_color_1, st, u_dye_1.xy, u_dye_1[2], u_dye_1[3]);
    vec4 dot_2 = blurDot(u_color_2, st, u_dye_2.xy, u_dye_2[2], u_dye_2[3]);
    vec4 dot_3 = blurDot(u_color_3, st, u_dye_3.xy, u_dye_3[2], u_dye_3[3]);
    vec4 dot_4 = blurDot(u_color_4, st, u_dye_4.xy, u_dye_4[2], u_dye_4[3]);
    vec4 dot_5 = blurDot(u_color_5, st, u_dye_5.xy, u_dye_5[2], u_dye_5[3]);
    
    color = mix(u_color_0, u_color_1, st.x);    
    color = mix(color, u_color_2, st.x*st.x + -0.040);

    color = mix(color, dot_0.rgb, dot_0.a);
    color = mix(color, dot_1.rgb, dot_1.a);
    color = mix(color, dot_2.rgb, dot_2.a);
    color = mix(color, dot_3.rgb, dot_3.a);
    color = mix(color, dot_4.rgb, dot_4.a);
    color = mix(color, dot_5.rgb, dot_5.a);

    gl_FragColor = vec4(color, 1.0);
  }
`;

const MAIN_FRAGMENT_SHADER = `
  precision highp float;
  uniform sampler2D tMap;
  uniform float uTime;
  uniform float uMagnitude;

  varying vec2 vUv;
  
  const float speed = 15.0;
  
  void main() {
    vec2 wavyCoord;
    wavyCoord.s = vUv.s + (sin(uTime+vUv.t*speed) * uMagnitude);
    wavyCoord.t = vUv.t + (cos(uTime+vUv.s*speed) * uMagnitude);
    vec4 frameColor = texture2D(tMap, wavyCoord);
    gl_FragColor = frameColor;
  }
`;

// Create a seedRandom function outside the component
function createSeedRandom(seed: number): () => number {
	const mask = 0xffffffff;
	let m_w = (123456789 + seed) & mask;
	let m_z = (987654321 - seed) & mask;

	return function () {
		m_z = (36969 * (m_z & 65535) + (m_z >>> 16)) & mask;
		m_w = (18000 * (m_w & 65535) + (m_w >>> 16)) & mask;
		let result = ((m_z << 16) + (m_w & 65535)) >>> 0;
		result /= 4294967296;
		return result;
	};
}

// Create a helper to detect device performance
const detectDevicePerformance = () => {
	// Check if running in a browser environment
	if (typeof window === 'undefined') return 'medium';

	// Check for low-end devices
	const isLowEnd =
		/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
		(navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4);

	// Check for high-end devices
	const isHighEnd =
		navigator.hardwareConcurrency &&
		navigator.hardwareConcurrency >= 8 &&
		!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

	if (isLowEnd) return 'low';
	if (isHighEnd) return 'high';
	return 'medium';
};

const AestheticFluidBg: React.FC<AestheticFluidBgProps> = ({
	colors = [],
	seed = 1000,
	loop = false,
	radius_inner = 0.1,
	radius_outer = 0.3,
	quality
}) => {
	useEffect(() => {
		console.log("This background's seed:", seed);
	}, []);
	const containerRef = useRef<HTMLDivElement>(null);
	const requestRef = useRef<number>(0);
	const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
	const sceneRef = useRef<THREE.Scene | null>(null);
	const cameraRef = useRef<THREE.OrthographicCamera | null>(null);
	const rttSceneRef = useRef<THREE.Scene | null>(null);
	const rttCameraRef = useRef<THREE.OrthographicCamera | null>(null);
	const rttRenderTargetRef = useRef<THREE.WebGLRenderTarget | null>(null);
	const planeRef = useRef<THREE.Mesh | null>(null);
	const frameRef = useRef<number>(0);
	const renderOnceRef = useRef<(() => void) | null>(null);
	const materialRefsRef = useRef<{
		rttMaterial: THREE.ShaderMaterial | null;
		planeMaterial: THREE.ShaderMaterial | null;
	}>({ rttMaterial: null, planeMaterial: null });
	const isVisibleRef = useRef<boolean>(true);
	const performanceTimingRef = useRef<{ lastFpsUpdate: number; frameCount: number; fps: number }>({
		lastFpsUpdate: 0,
		frameCount: 0,
		fps: 60
	});
	// RNG that updates when seed changes
	const rngRef = useRef<() => number>(() => Math.random());
	useEffect(() => {
		rngRef.current = createSeedRandom(seed);
	}, [seed]);

	// Detect device performance level if quality is not specified
	const effectiveQuality = useMemo(() => quality || detectDevicePerformance(), [quality]);

	// Memoize palette computation to avoid recalculations
	const palette = useMemo(() => {
		const colorsNum = 6;
		let newPalette: string[];

		if (colors.length === 0) {
			newPalette = [...defaultColors];
		} else if (colors.length < colorsNum) {
			newPalette = [...colors];
			for (let last = colors.length; last < colorsNum; last++) {
				const pointer = last % colors.length;
				newPalette.push(colors[pointer]);
			}
		} else {
			newPalette = colors.slice(0, colorsNum);
		}

		return newPalette;
	}, [colors]);

	// Memoize THREE.Colors to prevent recreation
	const threeColors = useMemo(() => palette.map((color) => new THREE.Color(color)), [palette]);

	// Reset dye points in the shader - optimization moved outside effect
	const resetDyePoints = (material: THREE.ShaderMaterial) => {
		const rng = rngRef.current;
		for (let i = 0; i < 6; i++) {
			const x = rng();
			const y = rng();
			const inner = rng() * radius_inner + radius_inner;
			const outer = rng() * radius_outer + radius_outer;

			material.uniforms[`u_dye_${i}`].value = new THREE.Vector4(x, y, inner, outer);
		}
	};

	// Apply morph targets - optimization moved outside effect
	const applyMorphTargets = (geometry: THREE.PlaneGeometry) => {
		if (!geometry.morphAttributes.position) {
			geometry.morphAttributes.position = [];

			// For each morph target, create a displacement
			for (const key in morphdata) {
				const data = morphdata[key];

				// Create a clone of the geometry positions
				const positionAttribute = geometry.attributes.position;
				const positions = new Float32Array(positionAttribute.count * 3);

				// Copy original positions
				for (let i = 0; i < positionAttribute.count; i++) {
					positions[i * 3] = positionAttribute.getX(i);
					positions[i * 3 + 1] = positionAttribute.getY(i);
					positions[i * 3 + 2] = positionAttribute.getZ(i);
				}

				// Apply the morph effect
				for (let i = 0; i < positions.length; i += 3) {
					const x = positions[i];
					const y = positions[i + 1];

					// Calculate distance from anchor point
					const dx = x - data.anchorX;
					const dy = y - data.anchorY;
					const distance = Math.sqrt(dx * dx + dy * dy);

					// Apply displacement based on distance
					if (distance < data.anchorRadius) {
						const factor = 1 - distance / data.anchorRadius;
						const moveVectorX = data.moveToX - data.anchorX;
						const moveVectorY = data.moveToY - data.anchorY;
						const moveVectorZ = data.moveToZ - data.anchorZ;

						positions[i] += moveVectorX * factor;
						positions[i + 1] += moveVectorY * factor;
						positions[i + 2] += moveVectorZ * factor;
					}
				}

				// Create a new buffer attribute for this morph target
				const morphAttribute = new THREE.BufferAttribute(positions, 3);
				geometry.morphAttributes.position.push(morphAttribute);
			}

			// Enable morphing
			geometry.morphTargetsRelative = true;
		}
	};

	// Initialize Three.js scene only once
	useEffect(() => {
		if (!containerRef.current || palette.length < 6) return;

		const container = containerRef.current;
		const width = container.clientWidth;
		const height = container.clientHeight;
		const size = width > height ? width : height;

		// Main scene setup - only create once
		const scene = new THREE.Scene();
		sceneRef.current = scene;

		// Create orthographic camera
		const camera = new THREE.OrthographicCamera(
			-width / 2,
			width / 2,
			height / 2,
			-height / 2,
			0.1,
			10001
		);
		camera.position.z = 8000;
		cameraRef.current = camera;

		// Create renderer with preserveDrawingBuffer for better performance with transparent backgrounds
		const renderer = new THREE.WebGLRenderer({
			antialias: effectiveQuality !== 'low', // Disable antialiasing for low quality
			alpha: true,
			powerPreference: 'high-performance', // Request high-performance GPU
			precision: effectiveQuality === 'high' ? 'highp' : 'mediump' // Adjust precision based on quality
		});
		renderer.setSize(width, height);
		renderer.setClearColor(0x000000, 0);

		// Set pixel ratio based on quality setting and device
		const devicePixelRatio = window.devicePixelRatio || 1;
		let limitedPixelRatio = devicePixelRatio;
		if (effectiveQuality === 'low') limitedPixelRatio = Math.min(devicePixelRatio, 1);
		else if (effectiveQuality === 'medium') limitedPixelRatio = Math.min(devicePixelRatio, 2);

		renderer.setPixelRatio(limitedPixelRatio);
		container.appendChild(renderer.domElement);
		rendererRef.current = renderer;

		// Add WebGL context loss/restore handlers
		renderer.domElement.addEventListener(
			'webglcontextlost',
			(event) => {
				event.preventDefault();
				console.log('WebGL context lost. Pausing rendering');
				if (requestRef.current) {
					cancelAnimationFrame(requestRef.current);
					requestRef.current = 0;
				}
			},
			false
		);

		renderer.domElement.addEventListener(
			'webglcontextrestored',
			() => {
				console.log('WebGL context restored. Resuming rendering');
				if (isVisibleRef.current) {
					if (loop) {
						if (!requestRef.current) requestRef.current = requestAnimationFrame(animate);
					} else {
						if (renderOnceRef.current) renderOnceRef.current();
					}
				}
			},
			false
		);

		// Setup RTT with optimized settings
		// Adjust RTT size based on quality
		const rttScale = effectiveQuality === 'high' ? 1 : effectiveQuality === 'medium' ? 0.75 : 0.5;
		const rttWidth = Math.floor(512 * rttScale); // Power of 2 for better GPU performance
		const rttHeight = Math.floor(512 * rttScale);

		const rttRenderTarget = new THREE.WebGLRenderTarget(rttWidth, rttHeight, {
			minFilter: THREE.LinearFilter,
			magFilter: THREE.LinearFilter,
			format: THREE.RGBAFormat,
			stencilBuffer: false,
			depthBuffer: false, // Don't need depth for this effect
			generateMipmaps: false // Don't need mipmaps
		});
		rttRenderTargetRef.current = rttRenderTarget;

		const rttScene = new THREE.Scene();
		rttSceneRef.current = rttScene;

		const rttCamera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 10);
		rttCamera.position.z = 1;
		rttCameraRef.current = rttCamera;

		// Create RTT plane
		const rttPlaneGeometry = new THREE.PlaneGeometry(1, 1);

		// Create the RTT shader material with memoized colors
		const rttMaterial = new THREE.ShaderMaterial({
			uniforms: {
				u_time: { value: 0.0 },
				u_resolution: { value: new THREE.Vector2(rttWidth, rttHeight) },
				u_color_0: { value: threeColors[0] },
				u_color_1: { value: threeColors[1] },
				u_color_2: { value: threeColors[2] },
				u_color_3: { value: threeColors[3] },
				u_color_4: { value: threeColors[4] },
				u_color_5: { value: threeColors[5] },
				u_dye_0: { value: new THREE.Vector4(0.3, 0.8, 0.1, 0.7) },
				u_dye_1: { value: new THREE.Vector4(0.7, 0.8, 0.1, 0.7) },
				u_dye_2: { value: new THREE.Vector4(0.7, 0.2, 0.1, 0.7) },
				u_dye_3: { value: new THREE.Vector4(0.3, 0.2, 0.1, 0.7) },
				u_dye_4: { value: new THREE.Vector4(0.1, 0.5, 0.1, 0.45) },
				u_dye_5: { value: new THREE.Vector4(0.9, 0.5, 0.1, 0.45) }
			},
			vertexShader: VERTEX_SHADER,
			fragmentShader: RTT_FRAGMENT_SHADER
		});

		materialRefsRef.current.rttMaterial = rttMaterial;

		const rttPlane = new THREE.Mesh(rttPlaneGeometry, rttMaterial);
		rttScene.add(rttPlane);

		// Reset dyeing points with random values
		resetDyePoints(rttMaterial);

		// Create main plane with adaptive resolution based on quality
		// Define segment count based on quality setting
		let segmentCount;
		if (effectiveQuality === 'low') {
			segmentCount = width > 1000 ? 32 : 24;
		} else if (effectiveQuality === 'medium') {
			segmentCount = width > 1000 ? 48 : 32;
		} else {
			segmentCount = width > 1000 ? 64 : 48;
		}

		const planeGeometry = new THREE.PlaneGeometry(size, size, segmentCount, segmentCount);

		// Apply morph targets for the convex surfaces
		applyMorphTargets(planeGeometry);

		const planeMaterial = new THREE.ShaderMaterial({
			uniforms: {
				tMap: { value: rttRenderTarget.texture },
				uTime: { value: 0 },
				uMagnitude: { value: 0.08 }
			},
			vertexShader: VERTEX_SHADER,
			fragmentShader: MAIN_FRAGMENT_SHADER
		});

		materialRefsRef.current.planeMaterial = planeMaterial;

		const plane = new THREE.Mesh(planeGeometry, planeMaterial);
		scene.add(plane);
		planeRef.current = plane;

		// Adaptive rendering rate based on device performance
		let lastTime = 0;
		// Lower target FPS on lower-end devices
		const targetFPS = effectiveQuality === 'low' ? 24 : 30;
		const interval = 1000 / targetFPS;

		// Helper to render a single frame (RTT + main)
		const renderOnce = () => {
			// Render RTT scene to the render target
			renderer.setRenderTarget(rttRenderTarget);
			renderer.render(rttScene, rttCamera);

			// Render main scene
			renderer.setRenderTarget(null);
			renderer.render(scene, camera);
		};
		renderOnceRef.current = renderOnce;

		const animate = (timestamp: number) => {
			// Performance metrics tracking
			performanceTimingRef.current.frameCount++;
			if (timestamp - performanceTimingRef.current.lastFpsUpdate >= 1000) {
				performanceTimingRef.current.fps = performanceTimingRef.current.frameCount;
				performanceTimingRef.current.frameCount = 0;
				performanceTimingRef.current.lastFpsUpdate = timestamp;
			}

			// Throttle rendering for performance
			if (timestamp - lastTime < interval && lastTime !== 0) {
				requestRef.current = requestAnimationFrame(animate);
				return;
			}

			lastTime = timestamp;

			if (loop) {
				frameRef.current++;
				// Slower animation for better performance, adapt based on quality
				const animSpeedFactor =
					effectiveQuality === 'low' ? 75 : effectiveQuality === 'medium' ? 60 : 50;
				planeMaterial.uniforms.uTime.value = frameRef.current / animSpeedFactor;
			}

			renderOnce();

			requestRef.current = requestAnimationFrame(animate);
		};

		if (isVisibleRef.current && loop) {
			requestRef.current = requestAnimationFrame(animate);
		} else {
			// Draw initial static frame when not looping
			renderOnce();
		}

		// Debounced resize handler for better performance
		let resizeTimeout: NodeJS.Timeout;
		const handleResize = () => {
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(() => {
				if (!container || !plane) return;

				const width = container.clientWidth;
				const height = container.clientHeight;
				const size = width > height ? width : height;

				// Update renderer size
				renderer.setSize(width, height);

				// Update camera
				camera.left = -width / 2;
				camera.right = width / 2;
				camera.top = height / 2;
				camera.bottom = -height / 2;
				camera.updateProjectionMatrix();

				// Update plane geometry to match new size
				const oldGeometry = plane.geometry;
				
				// Define segment count based on quality setting (same logic as initial creation)
				let segmentCount;
				if (effectiveQuality === 'low') {
					segmentCount = width > 1000 ? 32 : 24;
				} else if (effectiveQuality === 'medium') {
					segmentCount = width > 1000 ? 48 : 32;
				} else {
					segmentCount = width > 1000 ? 64 : 48;
				}

				const newGeometry = new THREE.PlaneGeometry(size, size, segmentCount, segmentCount);
				applyMorphTargets(newGeometry);
				
				plane.geometry = newGeometry;
				oldGeometry.dispose();

				// Re-render once after resize completes
				renderOnce();
			}, 250); // Debounce window resize events
		};

		window.addEventListener('resize', handleResize);

		// Add visibility change handler to pause rendering when tab is not active
		const handleVisibilityChange = () => {
			if (document.hidden) {
				isVisibleRef.current = false;
				if (requestRef.current) {
					cancelAnimationFrame(requestRef.current);
					requestRef.current = 0;
				}
			} else {
				isVisibleRef.current = true;
				if (loop) {
					if (!requestRef.current) requestRef.current = requestAnimationFrame(animate);
				} else {
					if (renderOnceRef.current) renderOnceRef.current();
				}
			}
		};

		document.addEventListener('visibilitychange', handleVisibilityChange);

		// Clean up
		return () => {
			if (requestRef.current) {
				cancelAnimationFrame(requestRef.current);
			}

			if (renderer.domElement && container.contains(renderer.domElement)) {
				container.removeChild(renderer.domElement);
			}

			// Clear timeouts
			clearTimeout(resizeTimeout);

			// Remove event listeners
			window.removeEventListener('resize', handleResize);
			document.removeEventListener('visibilitychange', handleVisibilityChange);
			renderer.domElement.removeEventListener('webglcontextlost', () => {});
			renderer.domElement.removeEventListener('webglcontextrestored', () => {});

			// Dispose all THREE.js resources
			rttRenderTarget.dispose();
			rttPlaneGeometry.dispose();
			rttMaterial.dispose();
			planeGeometry.dispose();
			planeMaterial.dispose();
			renderer.dispose();
		};
	}, [effectiveQuality, loop]);

	// Update color uniforms when palette changes
	useEffect(() => {
		const { rttMaterial } = materialRefsRef.current;
		if (!rttMaterial || palette.length < 6) return;

		// Update color uniforms
		for (let i = 0; i < 6; i++) {
			if (rttMaterial.uniforms[`u_color_${i}`]) {
				rttMaterial.uniforms[`u_color_${i}`].value = new THREE.Color(palette[i]);
			}
		}
	}, [palette]);

	// Update radius values when they change
	useEffect(() => {
		const { rttMaterial } = materialRefsRef.current;
		if (!rttMaterial) return;

		resetDyePoints(rttMaterial);
	}, [radius_inner, radius_outer]);

	// Scroll-linked animation: map scroll progress to shader uniforms
	const { scrollYProgress } = useScroll();
	const smoothProgress = useSpring(scrollYProgress, { stiffness: 120, damping: 30, mass: 0.8 });

	// Render once per progress change when not looping
	useMotionValueEvent(smoothProgress, 'change', (latest) => {
		if (loop) return; // let RAF handle updates when looping
		const { planeMaterial } = materialRefsRef.current;
		if (!planeMaterial) return;

		// Map progress to time and magnitude (less aggressive)
		const timeScale = 3; // fewer phase cycles per full page scroll
		const baseMag = 0.04;
		const extraMag = 0.06;

		planeMaterial.uniforms.uTime.value = latest * timeScale;
		planeMaterial.uniforms.uMagnitude.value = baseMag + latest * extraMag;

		// Render a single frame
		if (renderOnceRef.current) renderOnceRef.current();
	});

	// Ensure initial uniforms reflect current scroll position on mount
	useEffect(() => {
		if (loop) return;
		const { planeMaterial } = materialRefsRef.current;
		if (!planeMaterial) return;
		const latest = smoothProgress.get();
		const timeScale = 25;
		const baseMag = 0.04;
		const extraMag = 0.06;
		planeMaterial.uniforms.uTime.value = latest * timeScale;
		planeMaterial.uniforms.uMagnitude.value = baseMag + latest * extraMag;
		if (renderOnceRef.current) renderOnceRef.current();
	}, [loop, smoothProgress]);
	return (
		<div
			ref={containerRef}
			style={{
				width: '100%',
				height: '100%',
				position: 'relative',
				overflowX: 'hidden', // Prevent horizontal scrollbars
				userSelect: 'none', // Prevent text selection for better touch performance
				willChange: 'transform', // Hint to browser for optimization
				contain: 'strict' // Contain layout/paint/size for better performance
			}}
		/>
	);
};

// Use React.memo to prevent unnecessary re-renders
export default React.memo(AestheticFluidBg);
